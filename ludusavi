#!/usr/bin/env bash
set -euo pipefail

info() { printf "\033[1;34m[INFO]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[WARN]\033[0m %s\n" "$*"; }
err() { printf "\033[1;31m[ERROR]\033[0m %s\n" "$*"; }

TMPDIRS=()
cleanup() {
  for d in "${TMPDIRS[@]:-}"; do
    [ -n "$d" ] && rm -rf "$d" || true
  done
}
trap cleanup EXIT INT TERM

SERVICE_CONTENT=$(cat <<'EOF'
[Unit]
Description=Ludusavi automatic game saves backup

[Service]
Type=oneshot
ExecStart=%h/.local/bin/ludusavi backup --force
EOF
)

TIMER_CONTENT=$(cat <<'EOF'
[Unit]
Description=Run Ludusavi backup automatically

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
EOF
)

DEST_HOME="$HOME"
DEST_APP_DIR="$DEST_HOME/.local/share/ludusavi"
DEST_LOCAL_BIN="$DEST_HOME/.local/bin"
DEST_SYSTEMD_USER_DIR="$DEST_HOME/.config/systemd/user"
CONFIG_DIR="$DEST_HOME/.config/ludusavi"
BIN_NAME="ludusavi"

mkdir -p "$DEST_LOCAL_BIN"

ensure_cmd() {
  command -v "$1" >/dev/null 2>&1 || { warn "command '$1' not found; some steps may fail"; }
}

download() {
  local url="$1" out="$2"
  if command -v curl >/dev/null 2>&1; then
    curl -sSL -f -o "$out" "$url"
  elif command -v wget >/dev/null 2>&1; then
    wget -q -O "$out" "$url"
  else
    return 1
  fi
}

detect_basic_tools() {
  ensure_cmd cp
  ensure_cmd mkdir
  ensure_cmd sed
  ensure_cmd curl
  ensure_cmd tar
  ensure_cmd unzip || true
  ensure_cmd file
  ensure_cmd find
  ensure_cmd systemctl || true
}

install_binary() {
  local src="$1" dest_dir="$2" dest_path
  [ -f "$src" ] || { warn "source $src not found; skipping"; return 0; }
  mkdir -p "$dest_dir"
  dest_path="$dest_dir/$(basename "$src")"
  if [ -f "$dest_path" ]; then
    if cmp -s "$src" "$dest_path"; then
      info "$dest_path already up-to-date"
      return 0
    else
      mv "$dest_path" "$dest_path.bak.$(date +%s)" || true
      info "backed up existing $dest_path"
    fi
  fi
  cp -a "$src" "$dest_path"
  chmod +x "$dest_path"
  info "installed $dest_path"
}

fetch_and_install_latest_release() {
  local owner_repo="mtkennerly/ludusavi"
  local api_url="https://api.github.com/repos/${owner_repo}/releases/latest"

  if [ -x "$DEST_APP_DIR/ludusavi" ]; then
    local current_version
    current_version=$("$DEST_APP_DIR/ludusavi" --version 2>/dev/null | head -n1 || echo "unknown")
    info "existing ludusavi found: $current_version"
  fi

  local arch arch_pattern
  arch=$(uname -m || echo x86_64)
  case "$arch" in
    x86_64|x86-64|amd64) arch_pattern="x86_64|amd64|linux64|linux-x86_64" ;;
    aarch64|arm64) arch_pattern="aarch64|arm64|linux-arm64|linux-aarch64" ;;
    *) arch_pattern="linux" ;;
  esac

  info "Querying GitHub for latest release of ${owner_repo}"
  local urls
  local tmpd
  tmpd=$(mktemp -d)
  TMPDIRS+=("$tmpd")
  local api_output="$tmpd/api.json"
  if ! download "$api_url" "$api_output"; then
    warn "failed to fetch latest release metadata from GitHub API"
    return 1
  fi
  urls=$(grep -Eo '"browser_download_url": *"[^"]+"' "$api_output" | sed -E 's/.*"([^\"]+)".*/\1/') || urls=""

  if [ -z "$urls" ]; then
    warn "no release assets found via GitHub API"
    return 1
  fi

  local selected_url
  selected_url=$(printf "%s\n" "$urls" | grep -Ei linux | grep -Ei "$arch_pattern" | head -n1 || true)
  if [ -z "$selected_url" ]; then
    selected_url=$(printf "%s\n" "$urls" | grep -Ei linux | head -n1 || true)
  fi
  if [ -z "$selected_url" ]; then
    selected_url=$(printf "%s\n" "$urls" | head -n1)
  fi

  if [ -z "$selected_url" ]; then
    warn "could not select a release asset URL"
    return 1
  fi

  info "selected asset: $selected_url"
  local filename="$tmpd/asset"
  info "downloading asset to $filename"
  if ! download "$selected_url" "$filename"; then
    warn "failed to download asset"
    return 1
  fi

  mkdir -p "$DEST_APP_DIR"

  local filetype
  filetype=$(file "$filename")

  if echo "$filetype" | grep -qi 'gzip\|tar\|zstd'; then
    if echo "$filetype" | grep -qi 'zstd' && command -v zstd >/dev/null 2>&1; then
      tar -I zstd -xf "$filename" -C "$tmpd" 2>/dev/null || tar -xzf "$filename" -C "$tmpd" || true
    else
      tar -xzf "$filename" -C "$tmpd" 2>/dev/null || tar -xf "$filename" -C "$tmpd" || true
    fi
  elif echo "$filetype" | grep -qi 'zip'; then
    unzip -q "$filename" -d "$tmpd" 2>/dev/null || true
  else
    warn "unknown archive format: $filetype"
    return 1
  fi

  local found
  found=$(find "$tmpd" -type f -name ludusavi 2>/dev/null | head -n1 || true)
  if [ -n "$found" ]; then
    if [ -f "$DEST_APP_DIR/ludusavi" ]; then
      mv "$DEST_APP_DIR/ludusavi" "$DEST_APP_DIR/ludusavi.bak.$(date +%s)" || true
    fi
    mv "$found" "$DEST_APP_DIR/ludusavi"
    chmod +x "$DEST_APP_DIR/ludusavi"
    info "installed $DEST_APP_DIR/ludusavi from archive"
    return 0
  fi

  warn "failed to extract or locate ludusavi in downloaded asset"
  return 1
}

fetch_and_install_latest_rclone() {
  if command -v rclone >/dev/null 2>&1; then
    info "rclone already installed: $(rclone --version | head -n1)"
    return 0
  fi

  info "Installing rclone via official installer (will prompt for sudo)"

  local install_script
  if command -v curl >/dev/null 2>&1; then
    install_script=$(curl -fsSL https://rclone.org/install.sh) || { warn "failed to download rclone installer"; return 1; }
  else
    install_script=$(wget -qO- https://rclone.org/install.sh) || { warn "failed to download rclone installer"; return 1; }
  fi

  if ! echo "$install_script" | sudo bash; then
    warn "rclone installer failed"
    return 1
  fi

  if command -v rclone >/dev/null 2>&1; then
    ln -sf "$(command -v rclone)" "$DEST_LOCAL_BIN/rclone" 2>/dev/null || true
    info "installed rclone system-wide via official installer"
    return 0
  else
    warn "rclone install reported success but rclone not found on PATH"
    return 1
  fi
}

install_systemd_user_units() {
  mkdir -p "$DEST_SYSTEMD_USER_DIR"

  printf "%s\n" "$SERVICE_CONTENT" | sed -e "s|%h|$DEST_HOME|g" > "$DEST_SYSTEMD_USER_DIR/ludusavi-backup.service"
  info "wrote embedded ludusavi-backup.service to $DEST_SYSTEMD_USER_DIR"

  printf "%s\n" "$TIMER_CONTENT" > "$DEST_SYSTEMD_USER_DIR/ludusavi-backup.timer"
  info "wrote embedded ludusavi-backup.timer to $DEST_SYSTEMD_USER_DIR"

  info "installed systemd user units to $DEST_SYSTEMD_USER_DIR"

  if command -v systemctl >/dev/null 2>&1; then
    if systemctl --user daemon-reload >/dev/null 2>&1; then
      info "reloaded systemd --user daemon"
      if systemctl --user enable --now ludusavi-backup.timer >/dev/null 2>&1; then
        info "enabled and started ludusavi-backup.timer"
      else
        warn "could not enable/start ludusavi-backup.timer automatically; run: systemctl --user enable --now ludusavi-backup.timer"
      fi
    else
      warn "could not reload systemd --user; you may need to enable user systemd or run the commands manually"
    fi
  else
    warn "systemctl not available; unit files were copied but not enabled"
  fi
}

create_config_dir() {
  if [ -d "$CONFIG_DIR" ]; then
    info "config dir $CONFIG_DIR already exists"
  else
    mkdir -p "$CONFIG_DIR"
    info "created $CONFIG_DIR"
  fi
}

create_desktop_entry() {
  local desktop_dir="$DEST_HOME/.local/share/applications"
  mkdir -p "$desktop_dir"
  local desktop_file="$desktop_dir/ludusavi.desktop"
  local exec_path
  if [ -x "$DEST_LOCAL_BIN/$BIN_NAME" ]; then
    exec_path="$DEST_LOCAL_BIN/$BIN_NAME"
  else
    exec_path="$DEST_APP_DIR/$BIN_NAME"
  fi

  cat > "$desktop_file" <<EOF
[Desktop Entry]
Type=Application
Name=Ludusavi
Comment=Backup and restore game saves
Exec=$exec_path %U
Icon=ludusavi
Terminal=false
Categories=Utility;Game;
StartupNotify=false
EOF

  chmod 644 "$desktop_file"
  # mark executable so some desktop environments consider it trusted
  chmod +x "$desktop_file" || true
  info "wrote desktop entry to $desktop_file"
}

post_install_notes() {
  local final_path="$DEST_APP_DIR/$BIN_NAME"
  local installed_version
  installed_version=$("$final_path" --version 2>/dev/null | head -n1 || echo "unknown")
  
  cat <<EOF

========================================================================
  LUDUSAVI BACKUP SETUP: INSTALLATION COMPLETE
========================================================================

  Installed version: $installed_version

[1] VALIDATION
  - Binary location: $final_path
  - Check version:   $final_path --version
  - Check timer:     systemctl --user status ludusavi-backup.timer

[2] CRITICAL NEXT STEPS
  The automatic timer is installed, BUT backups will not work yet.
  
  1. OPEN Ludusavi manually now.
  2. CONFIGURE your backup destinations.
  3. SELECT the games you want to include.

  Note: Open Ludusavi periodically to add new games to the backup list.
========================================================================

EOF
}

main() {
  detect_basic_tools

  info "Installing Ludusavi into $DEST_APP_DIR (user-mode)"
  mkdir -p "$DEST_APP_DIR"

  if ! fetch_and_install_latest_release; then
    err "failed to install ludusavi - aborting"
    exit 1
  fi

  if ! fetch_and_install_latest_rclone; then
    warn "rclone installation failed - cloud sync features may not work"
  fi

  if [ -f "$DEST_APP_DIR/$BIN_NAME" ]; then
    ln -sf "$DEST_APP_DIR/$BIN_NAME" "$DEST_LOCAL_BIN/$BIN_NAME"
    info "symlinked $DEST_LOCAL_BIN/$BIN_NAME -> $DEST_APP_DIR/$BIN_NAME"
  fi

  install_systemd_user_units
  create_config_dir
  create_desktop_entry

  post_install_notes
}

main "$@"
